/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.08 from the
 * contents of GladeXML.xs. Do not edit this file, edit GladeXML.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "GladeXML.xs"
/*
 * $Header: /cvsroot/gtk2-perl/gtk2-perl-xs/Glade/GladeXML.xs,v 1.12 2004/11/28 17:24:36 rwmcfa1 Exp $
 *
 */

#include "gladexmlperl.h"

static GPerlCallback *
create_connect_func_handler_callback (SV * func, SV * data)
{
	GType param_types[] = {
		G_TYPE_STRING,
		G_TYPE_OBJECT,
		G_TYPE_STRING,
		G_TYPE_STRING,
		G_TYPE_OBJECT,
		G_TYPE_BOOLEAN
	};
	return gperl_callback_new (func, data,
	                           G_N_ELEMENTS (param_types),
	                           param_types,
	                           G_TYPE_NONE);
}

static void
connect_func_handler (const gchar *handler_name,
		      GObject     *object,
		      const gchar *signal_name,
		      const gchar *signal_data,
		      GObject     *connect_object,
		      gboolean     after,
		      gpointer     user_data)
{
#define IF_NULL_SET_EMPTY(var) \
	if( !(var) )		\
		(var) = "";
	IF_NULL_SET_EMPTY(handler_name);
	IF_NULL_SET_EMPTY(signal_name);
	IF_NULL_SET_EMPTY(signal_data);
#undef IF_NULL_SET_EMPTY

	gperl_callback_invoke ((GPerlCallback*) user_data,
	                       NULL,
			       handler_name,
			       object,
			       signal_name,
			       signal_data,
			       connect_object,
			       after,
			       user_data);
}

static GtkWidget*
glade_custom_widget(
	GladeXML * xml,
	gchar    * func_name,
	char     * name,
	char     * string1,
	char     * string2,
	int        int1,
	int        int2,
	gpointer   data
) {
	GPerlCallback * callback     = (GPerlCallback*)data;
	GValue          return_value = {0,};
	GtkWidget*      retval;
	g_value_init(&return_value, callback->return_type);
	gperl_callback_invoke(
		callback,       /*the perl subroutine*/
		&return_value,  /*to catch the return value*/
		xml,            /*the calling gladexml object*/
		func_name,      /*the widget creation function name*/
		name,           /*this widget's name for use with get_widget*/
		string1,        /*the four args from the xml file*/
		string2,
		int1,
		int2
	);
	/* dup refs, unset unrefs. */
	retval = (GtkWidget *)g_value_dup_object(&return_value);
	g_value_unset(&return_value);
	return retval;
}

#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#line 99 "GladeXML.c"
XS(XS_Gtk2__GladeXML_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Gtk2__GladeXML_new)
{
    dXSARGS;
    if (items < 2 || items > 4)
	Perl_croak(aTHX_ "Usage: Gtk2::GladeXML::new(class, filename, root=NULL, domain=NULL)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	GPerlFilename	filename = (GPerlFilename) gperl_filename_from_sv (ST(1));
	const char_ornull *	root;
	const char_ornull *	domain;
	GladeXML_ornull *	RETVAL;

	if (items < 3)
	    root = NULL;
	else {
	    if (ST(2) && SvOK (ST(2))) {
		    root = (const char_ornull *)SvPV_nolen (ST(2));
	    } else {
		    root = NULL;
	    };
	}

	if (items < 4)
	    domain = NULL;
	else {
	    if (ST(3) && SvOK (ST(3))) {
		    domain = (const char_ornull *)SvPV_nolen (ST(3));
	    } else {
		    domain = NULL;
	    };
	}

	RETVAL = glade_xml_new(filename, root, domain);
	ST(0) = newSVGladeXML_ornull(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Gtk2__GladeXML_new_from_buffer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Gtk2__GladeXML_new_from_buffer)
{
    dXSARGS;
    if (items < 2 || items > 4)
	Perl_croak(aTHX_ "Usage: Gtk2::GladeXML::new_from_buffer(class, buffer, root=NULL, domain=NULL)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	buffer = ST(1);
	const char_ornull *	root;
	const char_ornull *	domain;
#line 106 "GladeXML.xs"
	int   len;
	char *p;
#line 154 "GladeXML.c"
	GladeXML_ornull *	RETVAL;

	if (items < 3)
	    root = NULL;
	else {
	    if (ST(2) && SvOK (ST(2))) {
		    root = (const char_ornull *)SvPV_nolen (ST(2));
	    } else {
		    root = NULL;
	    };
	}

	if (items < 4)
	    domain = NULL;
	else {
	    if (ST(3) && SvOK (ST(3))) {
		    domain = (const char_ornull *)SvPV_nolen (ST(3));
	    } else {
		    domain = NULL;
	    };
	}
#line 109 "GladeXML.xs"
    	p = SvPV(buffer, len);
	RETVAL = glade_xml_new_from_buffer(p, len, root, domain);
#line 179 "GladeXML.c"
	ST(0) = newSVGladeXML_ornull(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Gtk2__GladeXML_signal_autoconnect); /* prototype to pass -Wmissing-prototypes */
XS(XS_Gtk2__GladeXML_signal_autoconnect)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Gtk2::GladeXML::signal_autoconnect(self, func, user_data=NULL)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	GladeXML *	self = SvGladeXML(ST(0));
	SV *	func = ST(1);
	SV *	user_data;
#line 145 "GladeXML.xs"
	GPerlCallback * real_callback;
#line 199 "GladeXML.c"

	if (items < 3)
	    user_data = NULL;
	else {
	    user_data = ST(2);
	}
#line 147 "GladeXML.xs"
	real_callback = create_connect_func_handler_callback (func, user_data);
    	glade_xml_signal_autoconnect_full (self,
	                                   connect_func_handler, 
	                                   real_callback);
	gperl_callback_destroy (real_callback);
#line 212 "GladeXML.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Gtk2__GladeXML_signal_connect_full); /* prototype to pass -Wmissing-prototypes */
XS(XS_Gtk2__GladeXML_signal_connect_full)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: Gtk2::GladeXML::signal_connect_full(self, handler_name, func, user_data=NULL)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	GladeXML *	self = SvGladeXML(ST(0));
	const gchar *	handler_name;
	SV *	func = ST(2);
	SV *	user_data;
#line 162 "GladeXML.xs"
	GPerlCallback * real_callback;
#line 231 "GladeXML.c"

	/* same as SvGChar(), but not in a function */
	sv_utf8_upgrade (ST(1));
	handler_name = (const gchar *)SvPV_nolen (ST(1));

	if (items < 4)
	    user_data = NULL;
	else {
	    user_data = ST(3);
	}
#line 164 "GladeXML.xs"
	real_callback = create_connect_func_handler_callback (func, user_data);
    	glade_xml_signal_connect_full (self, handler_name, connect_func_handler, 
				       real_callback);
	gperl_callback_destroy (real_callback);
#line 247 "GladeXML.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Gtk2__GladeXML_get_widget); /* prototype to pass -Wmissing-prototypes */
XS(XS_Gtk2__GladeXML_get_widget)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Gtk2::GladeXML::get_widget(self, name)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	GladeXML *	self = SvGladeXML(ST(0));
	const char *	name = (const char *)SvPV_nolen(ST(1));
	GtkWidget_ornull *	RETVAL;

	RETVAL = glade_xml_get_widget(self, name);
	ST(0) = newSVGtkWidget_ornull (RETVAL);

	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Gtk2__GladeXML_get_widget_prefix); /* prototype to pass -Wmissing-prototypes */
XS(XS_Gtk2__GladeXML_get_widget_prefix)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Gtk2::GladeXML::get_widget_prefix(self, name)");
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	GladeXML *	self = SvGladeXML(ST(0));
	const char *	name = (const char *)SvPV_nolen(ST(1));
#line 181 "GladeXML.xs"
	GList * widgets = NULL;
	GList * i = NULL;
#line 287 "GladeXML.c"
#line 184 "GladeXML.xs"
	widgets = glade_xml_get_widget_prefix(self, name);
	if( !widgets )
		XSRETURN_EMPTY;
	for( i = widgets; i != NULL; i = i->next )
		XPUSHs(sv_2mortal(newSVGtkWidget(i->data)));
	g_list_free(widgets);
#line 295 "GladeXML.c"
	PUTBACK;
	return;
    }
}

XS(XS_Gtk2__GladeXML_relative_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Gtk2__GladeXML_relative_file)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Gtk2::GladeXML::relative_file(self, filename)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	GladeXML *	self = SvGladeXML(ST(0));
	GPerlFilename	filename = (GPerlFilename) gperl_filename_from_sv (ST(1));
	gchar_own *	RETVAL;

	RETVAL = glade_xml_relative_file(self, filename);
	ST(0) = sv_newmortal();
	/* used when we can directly own the returned string. */
	/* we have to copy in the case when perl's malloc != gtk's malloc,
         * so best copy all the time. */
	sv_setpv ((SV*)ST(0), RETVAL);
	SvUTF8_on (ST(0));
        g_free (RETVAL);

    }
    XSRETURN(1);
}

XS(XS_Gtk2__Glade_set_custom_handler); /* prototype to pass -Wmissing-prototypes */
XS(XS_Gtk2__Glade_set_custom_handler)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Gtk2::Glade::set_custom_handler(class, callback, callback_data=NULL)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	callback = ST(1);
	SV *	callback_data;
#line 208 "GladeXML.xs"
        static GPerlCallback * real_callback = NULL;
        GType param_types [] = {
		GLADE_TYPE_XML,  /*gladexml object*/
		G_TYPE_STRING,   /*creation function name*/
		G_TYPE_STRING,   /*widget name*/
		G_TYPE_STRING,   /*string 1*/
		G_TYPE_STRING,   /*string 2*/
		G_TYPE_INT,      /*integer 1*/
		G_TYPE_INT       /*integer 2*/
	};
#line 347 "GladeXML.c"

	if (items < 3)
	    callback_data = NULL;
	else {
	    callback_data = ST(2);
	}
#line 219 "GladeXML.xs"
	if (real_callback)
		/* we're being called again... */
		gperl_callback_destroy (real_callback);
	real_callback = gperl_callback_new(
		callback,       /*perl function to treat as a callback*/
		callback_data,  /*extra data to pass to callback*/
		7,              /*number of parameters*/
		param_types,    /*list of parameters*/
		GTK_TYPE_WIDGET /*return type*/
	);
	glade_set_custom_handler (glade_custom_widget, real_callback);
#line 366 "GladeXML.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Gtk2__Widget_get_widget_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Gtk2__Widget_get_widget_name)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Gtk2::Widget::get_widget_name(widget)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	GtkWidget *	widget = SvGtkWidget (ST(0));
	const char *	RETVAL;
	dXSTARG;

	RETVAL = glade_get_widget_name(widget);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Gtk2__Widget_get_widget_tree); /* prototype to pass -Wmissing-prototypes */
XS(XS_Gtk2__Widget_get_widget_tree)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Gtk2::Widget::get_widget_tree(widget)");
    PERL_UNUSED_VAR(cv); /* -W */
    {
	GtkWidget *	widget = SvGtkWidget (ST(0));
	GladeXML *	RETVAL;

	RETVAL = glade_get_widget_tree(widget);
	ST(0) = newSVGladeXML(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Gtk2__GladeXML); /* prototype to pass -Wmissing-prototypes */
XS(boot_Gtk2__GladeXML)
{
    dXSARGS;
    char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("Gtk2::GladeXML::new", XS_Gtk2__GladeXML_new, file);
        newXS("Gtk2::GladeXML::new_from_buffer", XS_Gtk2__GladeXML_new_from_buffer, file);
        newXS("Gtk2::GladeXML::signal_autoconnect", XS_Gtk2__GladeXML_signal_autoconnect, file);
        newXS("Gtk2::GladeXML::signal_connect_full", XS_Gtk2__GladeXML_signal_connect_full, file);
        newXS("Gtk2::GladeXML::get_widget", XS_Gtk2__GladeXML_get_widget, file);
        newXS("Gtk2::GladeXML::get_widget_prefix", XS_Gtk2__GladeXML_get_widget_prefix, file);
        newXS("Gtk2::GladeXML::relative_file", XS_Gtk2__GladeXML_relative_file, file);
        newXS("Gtk2::Glade::set_custom_handler", XS_Gtk2__Glade_set_custom_handler, file);
        newXS("Gtk2::Widget::get_widget_name", XS_Gtk2__Widget_get_widget_name, file);
        newXS("Gtk2::Widget::get_widget_tree", XS_Gtk2__Widget_get_widget_tree, file);

    /* Initialisation Section */

#line 88 "GladeXML.xs"
	gperl_register_object (GLADE_TYPE_XML, "Gtk2::GladeXML");

#line 436 "GladeXML.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

