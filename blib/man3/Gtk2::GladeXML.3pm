.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GladeXML 3"
.TH GladeXML 3 "2005-01-11" "perl v5.8.3" "User Contributed Perl Documentation"
.SH "NAME"
Gtk2::GladeXML \- Create user interfaces directly from Glade XML files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Gtk2 -init;
\&  use Gtk2::GladeXML;
.Ve
.PP
.Vb 4
\&  $gladexml = Gtk2::GladeXML->new('example.glade');
\&  $gladexml->signal_autoconnect_from_package('main');
\&  $quitbtn = $gladexml->get_widget('Quit'); 
\&  Gtk2->main;
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Gtk2::GladeXML allows Perl programmers to use libglade, a C library which
generates graphical user interfaces directly from the \s-1XML\s0 output of the
Glade user interface designer.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Glade is a free user interface builder for \s-1GTK+\s0 and \s-1GNOME\s0.  After designing
a user interface with glade\-2 the layout and configuration are saved in an
\&\s-1XML\s0 file.  libglade is a library which knows how to build and hook up the
user interface described in the Glade \s-1XML\s0 file at application run time.
.PP
This extension module binds libglade to Perl so you can create and manipulate
user interfaces in Perl code in conjunction with Gtk2 and even Gnome2.  Better
yet you can load a file's contents into a \s-1PERL\s0 scalar do a few magical regular
expressions to customize things and the load up the app. It doesn't get any
easier. 
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "$gladexml = Gtk2::GladeXML\->new(\s-1GLADE_FILE\s0, [\s-1ROOT\s0, \s-1DOMAIN\s0])" 4
.IX Item "$gladexml = Gtk2::GladeXML->new(GLADE_FILE, [ROOT, DOMAIN])"
Create a new GladeXML object by loading the data in \s-1GLADE_FILE\s0.  \s-1ROOT\s0 is an
optional parameter that specifies a point (widget node) from which to start
building.  \s-1DOMAIN\s0 is an optional parameter that specifies the translation
domain for the xml file.
.IP "$gladexml = Gtk2::GladeXML\->new_from_buffer(\s-1BUFFER\s0, [\s-1ROOT\s0, \s-1DOMAIN\s0])" 4
.IX Item "$gladexml = Gtk2::GladeXML->new_from_buffer(BUFFER, [ROOT, DOMAIN])"
Create a new GladeXML object from the scalar string contained in \s-1BUFFER\s0.  \s-1ROOT\s0
is an optional parameter that specifies a point (widget node) from which to
start building.  \s-1DOMAIN\s0 is an optional parameter that specifies the translation
domain for the xml file.
.ie n .IP "$widget = $gladexml\->get_widget(\s-1NAME\s0)" 4
.el .IP "$widget = \f(CW$gladexml\fR\->get_widget(\s-1NAME\s0)" 4
.IX Item "$widget = $gladexml->get_widget(NAME)"
Return the widget created by the \s-1XML\s0 file with \s-1NAME\s0 or undef if no such name
exists.
.ie n .IP "$gladexml\->signal_autoconnect($callback[, $userdata])" 4
.el .IP "$gladexml\->signal_autoconnect($callback[, \f(CW$userdata\fR])" 4
.IX Item "$gladexml->signal_autoconnect($callback[, $userdata])"
Iterates over all signals and calls the given callback:
.Sp
.Vb 3
\&   sub example_cb {
\&      my ($name, $widget, $signal, $signal_data, $connect, $after, $userdata) = @_;
\&   }
.Ve
.Sp
The following two convenience methods use this to provide a more
convenient interface.
.IP "$gladexml\->signal_autoconnect_from_package([\s-1PACKAGE\s0])" 4
.IX Item "$gladexml->signal_autoconnect_from_package([PACKAGE])"
Sets up the signal handling callbacks as specified in the glade \s-1XML\s0 data.
Callbacks will need to have the exact name as specified in the \s-1XML\s0 data
and be located in the provided package (or the caller's package if none is
provided).  It is worth noting that callbacks you get for free in c such
as gtk_main_quit will not exist in perl and must always be defined, for
example:
.Sp
.Vb 4
\&  sub gtk_main_quit
\&  {
\&        Gtk2->main_quit;
\&  }
.Ve
.Sp
Otherwise behavior should be exactly as expected with the use of libglade
from a C application.
.IP "$gladexml\->signal_autoconnect_all (name => handler, ...)" 4
.IX Item "$gladexml->signal_autoconnect_all (name => handler, ...)"
Iterates over all named signals and tries to connect them to the handlers
specified as arguments (handlers not given as argument are being
ignored). This is very handy when implementing your own widgets, where you
can't use global callbacks.
.SH "FAQ"
.IX Header "FAQ"
.IP "Where is the option to generate Perl source in Glade?" 4
.IX Item "Where is the option to generate Perl source in Glade?"
Glade itself only creates the \s-1XML\s0 description, and relies on extra converter
programs to write source code; only a few converters are widely popular.
.Sp
In general, however, you don't want to generate source code for a variety of
reasons, mostly to do with maintainability.  This message on the glade-devel
list explains it best:
.Sp
http://lists.ximian.com/archives/public/glade\-devel/2003\-February/000015.html
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl(1), Glib(3pm), Gtk2(3pm)
.PP
The Libglade Reference Manual at http://developer.gnome.org/doc/API/2.0/libglade/
.SH "AUTHOR"
.IX Header "AUTHOR"
Ross McFarland <rwmcfa1 at neces dot com>, Marc Lehmann <pcg@goof.com>,
muppet <scott at asofyet dot org>.  Bruce Alderson provided several examples.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2003\-2004 by the gtk2\-perl team.
.PP
This library is free software; you can redistribute it and/or
modify it under the terms of the \s-1GNU\s0 Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.
.PP
This library is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0
Library General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 Library General Public
License along with this library; if not, write to the 
Free Software Foundation, Inc., 59 Temple Place \- Suite 330, 
Boston, \s-1MA\s0  02111\-1307  \s-1USA\s0.
